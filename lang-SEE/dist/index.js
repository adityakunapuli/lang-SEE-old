import { LRParser } from '@lezer/lr';
import { styleTags, tags } from '@lezer/highlight';
import { indentNodeProp, continuedIndent, foldNodeProp, foldInside, LRLanguage, LanguageSupport } from '@codemirror/language';
import { completeFromList } from '@codemirror/autocomplete';

const jsonHighlighting = styleTags({
        String: tags.string,
        Number: tags.number,
        "True False": tags.bool,
        PropertyName: tags.propertyName,
        Null: tags.null,
        ",": tags.separator,
        "[ ]": tags.squareBracket,
        "{ }": tags.brace,
        Keyword: tags.keyword,
        Bool: tags.bool,
        IfSet: tags.logicOperator,
        IfStatement: tags.logicOperator
    }
);

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_string = {__proto__:null,IF:40};
const parser = LRParser.deserialize({
  version: 14,
  states: "$zOYQPOOOOQO'#Cc'#CcO!QQPO'#CfO!YQPO'#CkOOQO'#Cn'#CnOOQO'#Cw'#CwOOQO'#Cq'#CqQYQPOOOOQO'#Co'#CoOOQO'#Ch'#ChO!aQPO'#CgO!fQPO'#CyOOQO,59Q,59QO!nQPO,59QO!sQPO'#C|OOQO,59V,59VO!{QPO,59VOOQO-E6o-E6oOYQPO,59RO!TQPO'#CrO#QQPO,59eOOQO1G.l1G.lOYQPO'#CsO#YQPO,59hOOQO1G.q1G.qOOQO1G.m1G.mOOQO,59^,59^OOQO-E6p-E6pOOQO,59_,59_OOQO-E6q-E6q",
  stateData: "#b~OjOSPOS~ORTOSTOTTOUTOXQO^RO`TOaTOdWOlPOqSOrSO~OW[OlXO~O]_O~PYOnbO~OocOWmX~OWeO~OofO]pX~O]hO~OocOWma~OofO]pa~O",
  goto: "!zqPPPPPPPrPPry!PPPrPPrrP!T!Z!aPPP!gP!tPP!wZTORVbfQZQRjcTYQcQVORaVQdZRkdQg^RmgSUOVQ^RQibRlfR]QR`R",
  nodeNames: "âš  Comment Form True False Null Number String } { Object Property PropertyName ] [ Array Keyword Bool IfSet IfStatement IF",
  maxTerm: 34,
  nodeProps: [
    ["group", -11,3,4,5,6,7,10,15,16,17,18,19,"Statement"],
    ["openedBy", 8,"{",13,"["],
    ["closedBy", 9,"}",14,"]"]
  ],
  propSources: [jsonHighlighting],
  skippedNodes: [0,1],
  repeatNodeCount: 3,
  tokenData: "2e~RnXY#PYZ#P]^#Ppq#Prs#Ust%n|}&Y}!O&_!Q!R'S!R![(b![!](s!c!d(x!e!f)Z!f!g*O!g!h*t!h!i,^!i!j,p!k!l/Q!q!r/]!u!v/c!x!y-Y!}#O/o#P#Q/t#X#Y/y#Y#Z0l#]#^.t#b#c1Z#h#i1r#o#p2Z#q#r2`~#UOj~~#XWpq#Uqr#Urs#qs#O#U#O#P#v#P;'S#U;'S;=`%h<%lO#U~#vOl~~#yXrs#U!P!Q#U#O#P#U#U#V#U#Y#Z#U#b#c#U#f#g#U#h#i#U#i#j$f~$iR!Q![$r!c!i$r#T#Z$r~$uR!Q![%O!c!i%O#T#Z%O~%RR!Q![%[!c!i%[#T#Z%[~%_R!Q![#U!c!i#U#T#Z#U~%kP;=`<%l#U~%sTP~OY%nZ]%n^;'S%n;'S;=`&S<%lO%n~&VP;=`<%l%n~&_Oo~~&bRpq&k!Q!R'S!R![(b~&nP!u!v&q~&tP#X#Y&w~&zP#h#i&}~'SOr~~'XRU~!O!P'b!g!h'v#X#Y'v~'eP!Q!['h~'mRU~!Q!['h!g!h'v#X#Y'v~'yR{|(S}!O(S!Q![(Y~(VP!Q![(Y~(_PU~!Q![(Y~(gSU~!O!P'b!Q![(b!g!h'v#X#Y'v~(xOn~~({P!p!q)O~)RP!f!g)U~)ZOa~~)^P!t!u)a~)dP!g!h)g~)jP!c!d)m~)pP!v!w)s~)vP!g!h)y~*OO`~~*RP!k!l*U~*XP!u!v*[~*_P!r!s*b~*eP!n!o*h~*kP!c!d*n~*qP!{!|)y~*wS!n!o+T!p!q+u#`#a.[#b#c.z~+WP!u!v+Z~+^P!g!h+a~+fP`~pq+i~+lP!k!l+o~+rP!h!i)y~+xP!f!g+{~,QS`~!e!f)Z!h!i,^!i!j,p!x!y-Y~,aP!q!r,d~,gP!t!u,j~,mP!o!p)y~,sP!k!l,v~,yP!x!y,|~-PP!g!h-S~-VP!p!q)y~-]P!c!d-`~-cP!n!o-f~-iP!k!l-l~-oP!f!g-r~-uP!c!d-x~-{P!v!w.O~.RP!k!l.U~.XP!q!r-S~._P#g#h.b~.eP#X#Y.h~.kPpq.n~.qP!k!l.t~.wP#Y#Z)y~.}P#W#X)y~/TP!h!i/W~/]Oq~~/`P!t!u)U~/fP!g!h/i~/lP!v!w)y~/tO^~~/yO]~~/|Q#`#a0S#b#c.z~0VP#g#h0Y~0]P#X#Y0`~0cPpq0f~0iP#]#^.t~0oP#T#U0r~0uP#`#a0x~0{P#g#h1O~1RP#X#Y1U~1ZOS~~1^P#i#j1a~1dP#`#a1g~1jP#`#a1m~1rOT~~1uP#f#g1x~1{P#i#j2O~2RP#X#Y2U~2ZOR~~2`OX~~2eOW~",
  tokenizers: [0],
  topRules: {"Form":[0,2]},
  specialized: [{term: 28, get: value => spec_string[value] || -1}],
  tokenPrec: 0
});

// noinspection RegExpRedundantEscape,JSUnusedLocalSymbols
function indentBody(context, node) {
    let base = context.lineIndent(node.from);
    let line = context.lineAt(context.pos, -1), to = line.from + line.text.length;
    // Don't consider blank, deindented lines at the end of the
    // block part of the block
    if (!/\S/.test(line.text) &&
        context.node.to < to + 100 &&
        !/\S/.test(context.state.sliceDoc(to, context.node.to)) &&
        context.lineIndent(context.pos, -1) <= base)
        return null;
    // A normally deindenting keyword that appears at a higher
    // indentation than the block should probably be handled by the next
    // level
    if (/^\s*(else:|elif |except |finally:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base)
        return null;
    return base + context.unit;
}
let parserWithMetadata = parser.configure({
    props: [
        indentNodeProp.add({
            IfSet: continuedIndent({ except: /^\s*\}/ }),
            Array: continuedIndent({ except: /^\s*\]/ }),
            IfStatement: continuedIndent({ except: /^\s*\}/ }),
            // IfSet: context => indentBody(context, context.node) ?? context.continue(),
            // IfSet: cx =>  /^\s*\}$/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
            Script: context => {
                if (context.pos + /\s*/.exec(context.textAfter)[0].length >= context.node.to) {
                    let endBody = null;
                    for (let cur = context.node, to = cur.to;;) {
                        cur = cur.lastChild;
                        if (!cur || cur.to != to)
                            break;
                        if (cur.type.name == "Body")
                            endBody = cur;
                    }
                    if (endBody) {
                        let bodyIndent = indentBody(context, endBody);
                        if (bodyIndent != null)
                            return bodyIndent;
                    }
                }
                return context.continue();
            }
        }),
        foldNodeProp.add({
            "IfSet Object Array": foldInside
        }),
        styleTags({
            Identifier: tags.variableName,
            Boolean: tags.bool,
            String: tags.string,
            Comment: tags.comment,
            "( )": tags.paren
        }),
    ]
});
const SEELanguage = LRLanguage.define({
    parser: parserWithMetadata,
    languageData: {
        commentTokens: { line: "#" },
        indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:|set )$/
    }
});
const completions = [
    { "label": "CREATE", "type": "function" },
    { "label": "FORM", "type": "keyword" },
    { "label": "ENDFORM", "type": "keyword" },
    { "label": "VALIDATION", "type": "keyword" },
    { "label": "GIVEN", "type": "keyword" },
    { "label": "ENDGIVEN", "type": "keyword" },
    { "label": "IF", "type": "bool" },
    { "label": "AND", "type": "bool" },
    { "label": "OR", "type": "bool" },
    { "label": "SET", "type": "keyword" },
    { "label": "DISPLAY", "type": "keyword" },
    { "label": "END", "type": "book" },
    { "label": "ENDVALIDATION", "type": "keyword" },
    { "label": "ENDCREATE", "type": "keyword" },
    { "label": "park", "type": "constant", "info": "Test completion" },
    { "label": "password", "type": "variable" }
];
const SEECompletion = SEELanguage.data.of({
    autocomplete: completeFromList(completions)
});
function SEE() {
    return new LanguageSupport(SEELanguage, [SEECompletion]);
}

export { SEE, SEECompletion, SEELanguage, completions, parserWithMetadata };
