'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var lr = require('@lezer/lr');
var highlight = require('@lezer/highlight');
var language = require('@codemirror/language');
var autocomplete = require('@codemirror/autocomplete');
var view = require('@codemirror/view');
var state = require('@codemirror/state');

const jsonHighlighting = highlight.styleTags({
        String: highlight.tags.string,
        Number: highlight.tags.number,
        "True False": highlight.tags.bool,
        PropertyName: highlight.tags.propertyName,
        Null: highlight.tags.null,
        ",": highlight.tags.separator,
        "[ ]": highlight.tags.squareBracket,
        "{ }": highlight.tags.brace,
        Keyword: highlight.tags.keyword,
        Bool: highlight.tags.bool,
        IfSet: highlight.tags.logicOperator,
        IfStatement: highlight.tags.logicOperator
    }
);

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_string = {__proto__:null,IF:40};
const parser = lr.LRParser.deserialize({
  version: 14,
  states: "$zOYQPOOOOQO'#Cc'#CcO!QQPO'#CfO!YQPO'#CkOOQO'#Cn'#CnOOQO'#Cw'#CwOOQO'#Cq'#CqQYQPOOOOQO'#Co'#CoOOQO'#Ch'#ChO!aQPO'#CgO!fQPO'#CyOOQO,59Q,59QO!nQPO,59QO!sQPO'#C|OOQO,59V,59VO!{QPO,59VOOQO-E6o-E6oOYQPO,59RO!TQPO'#CrO#QQPO,59eOOQO1G.l1G.lOYQPO'#CsO#YQPO,59hOOQO1G.q1G.qOOQO1G.m1G.mOOQO,59^,59^OOQO-E6p-E6pOOQO,59_,59_OOQO-E6q-E6q",
  stateData: "#b~OjOSPOS~ORTOSTOTTOUTOXQO^RO`TOaTOdWOlPOqSOrSO~OW[OlXO~O]_O~PYOnbO~OocOWmX~OWeO~OofO]pX~O]hO~OocOWma~OofO]pa~O",
  goto: "!zqPPPPPPPrPPry!PPPrPPrrP!T!Z!aPPP!gP!tPP!wZTORVbfQZQRjcTYQcQVORaVQdZRkdQg^RmgSUOVQ^RQibRlfR]QR`R",
  nodeNames: "âš  Comment Form True False Null Number String } { Object Property PropertyName ] [ Array Keyword Bool IfSet IfStatement IF",
  maxTerm: 34,
  nodeProps: [
    ["group", -11,3,4,5,6,7,10,15,16,17,18,19,"Statement"],
    ["openedBy", 8,"{",13,"["],
    ["closedBy", 9,"}",14,"]"]
  ],
  propSources: [jsonHighlighting],
  skippedNodes: [0,1],
  repeatNodeCount: 3,
  tokenData: "4P~RoXY#SYZ#S]^#Spq#Srs#Xst%q|}&]}!O&b!Q!R'V!R![(e![!](v!^!_({!c!d)p!e!f*R!f!g*q!g!h+g!h!i0]!i!j-c!k!l0l!q!r0w!u!v0}!x!y-{!}#O1Z#P#Q1`#X#Y1e#Y#Z2W#]#^0P#b#c2u#h#i3^#o#p3u#q#r3z~#XOj~~#[Wpq#Xqr#Xrs#ts#O#X#O#P#y#P;'S#X;'S;=`%k<%lO#X~#yOl~~#|Xrs#X!P!Q#X#O#P#X#U#V#X#Y#Z#X#b#c#X#f#g#X#h#i#X#i#j$i~$lR!Q![$u!c!i$u#T#Z$u~$xR!Q![%R!c!i%R#T#Z%R~%UR!Q![%_!c!i%_#T#Z%_~%bR!Q![#X!c!i#X#T#Z#X~%nP;=`<%l#X~%vTP~OY%qZ]%q^;'S%q;'S;=`&V<%lO%q~&YP;=`<%l%q~&bOo~~&eRpq&n!Q!R'V!R![(e~&qP!u!v&t~&wP#X#Y&z~&}P#h#i'Q~'VOr~~'[RU~!O!P'e!g!h'y#X#Y'y~'hP!Q!['k~'pRU~!Q!['k!g!h'y#X#Y'y~'|R{|(V}!O(V!Q![(]~(YP!Q![(]~(bPU~!Q![(]~(jSU~!O!P'e!Q![(e!g!h'y#X#Y'y~({On~~)OP#[#])R~)UP#h#i)X~)[P#a#b)_~)bP#`#a)e~)hP!`!a)k~)pO`~~)sP!p!q)v~)yP!f!g)|~*ROa~~*UP!t!u*X~*[P!g!h*_~*bP!c!d*e~*hP!v!w*k~*nP!g!h)k~*tP!k!l*w~*zP!u!v*}~+QP!r!s+T~+WP!n!o+Z~+^P!c!d+a~+dP!{!|)k~+jS!n!o+v!p!q,h#`#a.}#b#c0V~+yP!u!v+|~,PP!g!h,S~,XP`~pq,[~,_P!k!l,b~,eP!h!i)k~,kP!f!g,n~,sS`~!e!f*R!h!i-P!i!j-c!x!y-{~-SP!q!r-V~-YP!t!u-]~-`P!o!p)k~-fP!k!l-i~-lP!x!y-o~-rP!g!h-u~-xP!p!q)k~.OP!c!d.R~.UP!n!o.X~.[P!k!l._~.bP!f!g.e~.hP!c!d.k~.nP!v!w.q~.tP!k!l.w~.zP!q!r-u~/QP#g#h/T~/WP#X#Y/Z~/^PYZ/a~/dPpq/g~/jPpq/m~/pPpq/s~/vPpq/y~/|P!k!l0P~0SP#Y#Z)k~0YP#W#X)k~0`P!q!r0c~0fQ!q!r)k!t!u-]~0oP!h!i0r~0wOq~~0zP!t!u)|~1QP!g!h1T~1WP!v!w)k~1`O^~~1eO]~~1hQ#`#a1n#b#c0V~1qP#g#h1t~1wP#X#Y1z~1}Ppq2Q~2TP#]#^0P~2ZP#T#U2^~2aP#`#a2d~2gP#g#h2j~2mP#X#Y2p~2uOS~~2xP#i#j2{~3OP#`#a3R~3UP#`#a3X~3^OT~~3aP#f#g3d~3gP#i#j3j~3mP#X#Y3p~3uOR~~3zOX~~4POW~",
  tokenizers: [0],
  topRules: {"Form":[0,2]},
  specialized: [{term: 28, get: value => spec_string[value] || -1}],
  tokenPrec: 0
});

const Targets = ["_blank", "_self", "_top", "_parent"];
const Charsets = ["ascii", "utf-8", "utf-16", "latin1", "latin1"];
const Methods = ["get", "post", "put", "delete"];
const Encs = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"];
const Bool = ["true", "false"];
const S = {}; // Empty tag spec
const Tags = {
    a: {
        attrs: {
            href: null, ping: null, type: null,
            media: null,
            target: Targets,
            hreflang: null
        }
    },
    abbr: S,
    address: S,
    area: {
        attrs: {
            alt: null, coords: null, href: null, target: null, ping: null,
            media: null, hreflang: null, type: null,
            shape: ["default", "rect", "circle", "poly"]
        }
    },
    article: S,
    aside: S,
    audio: {
        attrs: {
            src: null, mediagroup: null,
            crossorigin: ["anonymous", "use-credentials"],
            preload: ["none", "metadata", "auto"],
            autoplay: ["autoplay"],
            loop: ["loop"],
            controls: ["controls"]
        }
    },
    b: S,
    base: { attrs: { href: null, target: Targets } },
    bdi: S,
    bdo: S,
    blockquote: { attrs: { cite: null } },
    body: S,
    br: S,
    button: {
        attrs: {
            form: null, formaction: null, name: null, value: null,
            autofocus: ["autofocus"],
            disabled: ["autofocus"],
            formenctype: Encs,
            formmethod: Methods,
            formnovalidate: ["novalidate"],
            formtarget: Targets,
            type: ["submit", "reset", "button"]
        }
    },
    canvas: { attrs: { width: null, height: null } },
    caption: S,
    center: S,
    cite: S,
    code: S,
    col: { attrs: { span: null } },
    colgroup: { attrs: { span: null } },
    command: {
        attrs: {
            type: ["command", "checkbox", "radio"],
            label: null, icon: null, radiogroup: null, command: null, title: null,
            disabled: ["disabled"],
            checked: ["checked"]
        }
    },
    data: { attrs: { value: null } },
    datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
    datalist: { attrs: { data: null } },
    dd: S,
    del: { attrs: { cite: null, datetime: null } },
    details: { attrs: { open: ["open"] } },
    dfn: S,
    div: S,
    dl: S,
    dt: S,
    em: S,
    embed: { attrs: { src: null, type: null, width: null, height: null } },
    eventsource: { attrs: { src: null } },
    fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
    figcaption: S,
    figure: S,
    footer: S,
    form: {
        attrs: {
            action: null, name: null,
            "accept-charset": Charsets,
            autocomplete: ["on", "off"],
            enctype: Encs,
            method: Methods,
            novalidate: ["novalidate"],
            target: Targets
        }
    },
    h1: S, h2: S, h3: S, h4: S, h5: S, h6: S,
    head: {
        children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
    },
    header: S,
    hgroup: S,
    hr: S,
    html: {
        attrs: { manifest: null }
    },
    i: S,
    iframe: {
        attrs: {
            src: null, srcdoc: null, name: null, width: null, height: null,
            sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
            seamless: ["seamless"]
        }
    },
    img: {
        attrs: {
            alt: null, src: null, ismap: null, usemap: null, width: null, height: null,
            crossorigin: ["anonymous", "use-credentials"]
        }
    },
    input: {
        attrs: {
            alt: null, dirname: null, form: null, formaction: null,
            height: null, list: null, max: null, maxlength: null, min: null,
            name: null, pattern: null, placeholder: null, size: null, src: null,
            step: null, value: null, width: null,
            accept: ["audio/*", "video/*", "image/*"],
            autocomplete: ["on", "off"],
            autofocus: ["autofocus"],
            checked: ["checked"],
            disabled: ["disabled"],
            formenctype: Encs,
            formmethod: Methods,
            formnovalidate: ["novalidate"],
            formtarget: Targets,
            multiple: ["multiple"],
            readonly: ["readonly"],
            required: ["required"],
            type: ["hidden", "text", "search", "tel", "url", "email", "password", "datetime", "date", "month",
                "week", "time", "datetime-local", "number", "range", "color", "checkbox", "radio",
                "file", "submit", "image", "reset", "button"]
        }
    },
    ins: { attrs: { cite: null, datetime: null } },
    kbd: S,
    keygen: {
        attrs: {
            challenge: null, form: null, name: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            keytype: ["RSA"]
        }
    },
    label: { attrs: { for: null, form: null } },
    legend: S,
    li: { attrs: { value: null } },
    link: {
        attrs: {
            href: null, type: null,
            hreflang: null,
            media: null,
            sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
        }
    },
    map: { attrs: { name: null } },
    mark: S,
    menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
    meta: {
        attrs: {
            content: null,
            charset: Charsets,
            name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
            "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
        }
    },
    meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
    nav: S,
    noscript: S,
    object: {
        attrs: {
            data: null, type: null, name: null, usemap: null, form: null, width: null, height: null,
            typemustmatch: ["typemustmatch"]
        }
    },
    ol: {
        attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
        children: ["li", "script", "template", "ul", "ol"]
    },
    optgroup: { attrs: { disabled: ["disabled"], label: null } },
    option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
    output: { attrs: { for: null, form: null, name: null } },
    p: S,
    param: { attrs: { name: null, value: null } },
    pre: S,
    progress: { attrs: { value: null, max: null } },
    q: { attrs: { cite: null } },
    rp: S,
    rt: S,
    ruby: S,
    samp: S,
    script: {
        attrs: {
            type: ["text/javascript"],
            src: null,
            async: ["async"],
            defer: ["defer"],
            charset: Charsets
        }
    },
    section: S,
    select: {
        attrs: {
            form: null, name: null, size: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            multiple: ["multiple"]
        }
    },
    slot: { attrs: { name: null } },
    small: S,
    source: { attrs: { src: null, type: null, media: null } },
    span: S,
    strong: S,
    style: {
        attrs: {
            type: ["text/css"],
            media: null,
            scoped: null
        }
    },
    sub: S,
    summary: S,
    sup: S,
    table: S,
    tbody: S,
    td: { attrs: { colspan: null, rowspan: null, headers: null } },
    template: S,
    textarea: {
        attrs: {
            dirname: null, form: null, maxlength: null, name: null, placeholder: null,
            rows: null, cols: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            readonly: ["readonly"],
            required: ["required"],
            wrap: ["soft", "hard"]
        }
    },
    tfoot: S,
    th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
    thead: S,
    time: { attrs: { datetime: null } },
    title: S,
    tr: S,
    track: {
        attrs: {
            src: null, label: null, default: null,
            kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
            srclang: null
        }
    },
    ul: { children: ["li", "script", "template", "ul", "ol"] },
    var: S,
    video: {
        attrs: {
            src: null, poster: null, width: null, height: null,
            crossorigin: ["anonymous", "use-credentials"],
            preload: ["auto", "metadata", "none"],
            autoplay: ["autoplay"],
            mediagroup: ["movie"],
            muted: ["muted"],
            controls: ["controls"]
        }
    },
    wbr: S
};
const GlobalAttrs = {
    accesskey: null,
    class: null,
    contenteditable: Bool,
    contextmenu: null,
    dir: ["ltr", "rtl", "auto"],
    draggable: ["true", "false", "auto"],
    dropzone: ["copy", "move", "link", "string:", "file:"],
    hidden: ["hidden"],
    id: null,
    inert: ["inert"],
    itemid: null,
    itemprop: null,
    itemref: null,
    itemscope: ["itemscope"],
    itemtype: null,
    lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
    spellcheck: Bool,
    autocorrect: Bool,
    autocapitalize: Bool,
    style: null,
    tabindex: null,
    title: null,
    translate: ["yes", "no"],
    rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
    role: "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
    "aria-activedescendant": null,
    "aria-atomic": Bool,
    "aria-autocomplete": ["inline", "list", "both", "none"],
    "aria-busy": Bool,
    "aria-checked": ["true", "false", "mixed", "undefined"],
    "aria-controls": null,
    "aria-describedby": null,
    "aria-disabled": Bool,
    "aria-dropeffect": null,
    "aria-expanded": ["true", "false", "undefined"],
    "aria-flowto": null,
    "aria-grabbed": ["true", "false", "undefined"],
    "aria-haspopup": Bool,
    "aria-hidden": Bool,
    "aria-invalid": ["true", "false", "grammar", "spelling"],
    "aria-label": null,
    "aria-labelledby": null,
    "aria-level": null,
    "aria-live": ["off", "polite", "assertive"],
    "aria-multiline": Bool,
    "aria-multiselectable": Bool,
    "aria-owns": null,
    "aria-posinset": null,
    "aria-pressed": ["true", "false", "mixed", "undefined"],
    "aria-readonly": Bool,
    "aria-relevant": null,
    "aria-required": Bool,
    "aria-selected": ["true", "false", "undefined"],
    "aria-setsize": null,
    "aria-sort": ["ascending", "descending", "none", "other"],
    "aria-valuemax": null,
    "aria-valuemin": null,
    "aria-valuenow": null,
    "aria-valuetext": null
};
const eventAttributes = ("beforeunload copy cut dragstart dragover dragleave dragenter dragend " +
    "drag paste focus blur change click load mousedown mouseenter mouseleave " +
    "mouseup keydown keyup resize scroll unload").split(" ").map(n => "on" + n);
for (let a of eventAttributes)
    GlobalAttrs[a] = null;
class Schema {
    constructor(extraTags, extraAttrs) {
        this.tags = Object.assign(Object.assign({}, Tags), extraTags);
        this.globalAttrs = Object.assign(Object.assign({}, GlobalAttrs), extraAttrs);
        this.allTags = Object.keys(this.tags);
        this.globalAttrNames = Object.keys(this.globalAttrs);
    }
}
Schema.default = new Schema;
function elementName(doc, tree, max = doc.length) {
    if (!tree)
        return "";
    let tag = tree.firstChild;
    let name = tag && tag.getChild("TagName");
    return name ? doc.sliceString(name.from, Math.min(name.to, max)) : "";
}
function findParentElement(tree, skip = false) {
    for (let cur = tree.parent; cur; cur = cur.parent)
        if (cur.name == "Element") {
            if (skip)
                skip = false;
            else
                return cur;
        }
    return null;
}
function allowedChildren(doc, tree, schema) {
    let parentInfo = schema.tags[elementName(doc, findParentElement(tree, true))];
    return (parentInfo === null || parentInfo === void 0 ? void 0 : parentInfo.children) || schema.allTags;
}
function openTags(doc, tree) {
    let open = [];
    for (let parent = tree; parent = findParentElement(parent);) {
        let tagName = elementName(doc, parent);
        if (tagName && parent.lastChild.name == "CloseTag")
            break;
        if (tagName && open.indexOf(tagName) < 0 && (tree.name == "EndTag" || tree.from >= parent.firstChild.to))
            open.push(tagName);
    }
    return open;
}
const identifier = /^[:\-\.\w\u00b7-\uffff]*$/;
function completeTag(state, schema, tree, from, to) {
    let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
    return {
        from, to,
        options: allowedChildren(state.doc, tree, schema).map(tagName => ({ label: tagName, type: "type" })).concat(openTags(state.doc, tree).map((tag, i) => ({
            label: "/" + tag, apply: "/" + tag + end,
            type: "type", boost: 99 - i
        }))),
        validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
    };
}
function completeCloseTag(state, tree, from, to) {
    let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
    return {
        from, to,
        options: openTags(state.doc, tree).map((tag, i) => ({ label: tag, apply: tag + end, type: "type", boost: 99 - i })),
        validFor: identifier
    };
}
function completeStartTag(state, schema, tree, pos) {
    let options = [], level = 0;
    for (let tagName of allowedChildren(state.doc, tree, schema))
        options.push({ label: "<" + tagName, type: "type" });
    for (let open of openTags(state.doc, tree))
        options.push({ label: "</" + open + ">", type: "type", boost: 99 - level++ });
    return { from: pos, to: pos, options, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function completeAttrName(state, schema, tree, from, to) {
    let elt = findParentElement(tree), info = elt ? schema.tags[elementName(state.doc, elt)] : null;
    let localAttrs = info && info.attrs ? Object.keys(info.attrs) : [];
    let names = info && info.globalAttrs === false ? localAttrs
        : localAttrs.length ? localAttrs.concat(schema.globalAttrNames) : schema.globalAttrNames;
    return {
        from, to,
        options: names.map(attrName => ({ label: attrName, type: "property" })),
        validFor: identifier
    };
}
function completeAttrValue(state, schema, tree, from, to) {
    var _a;
    let nameNode = (_a = tree.parent) === null || _a === void 0 ? void 0 : _a.getChild("AttributeName");
    let options = [], token = undefined;
    if (nameNode) {
        let attrName = state.sliceDoc(nameNode.from, nameNode.to);
        let attrs = schema.globalAttrs[attrName];
        if (!attrs) {
            let elt = findParentElement(tree), info = elt ? schema.tags[elementName(state.doc, elt)] : null;
            attrs = (info === null || info === void 0 ? void 0 : info.attrs) && info.attrs[attrName];
        }
        if (attrs) {
            let base = state.sliceDoc(from, to).toLowerCase(), quoteStart = '"', quoteEnd = '"';
            if (/^['"]/.test(base)) {
                token = base[0] == '"' ? /^[^"]*$/ : /^[^']*$/;
                quoteStart = "";
                quoteEnd = state.sliceDoc(to, to + 1) == base[0] ? "" : base[0];
                base = base.slice(1);
                from++;
            }
            else {
                token = /^[^\s<>='"]*$/;
            }
            for (let value of attrs)
                options.push({ label: value, apply: quoteStart + value + quoteEnd, type: "constant" });
        }
    }
    return { from, to, options, validFor: token };
}
function htmlCompletionFor(schema, context) {
    let { state, pos } = context, around = language.syntaxTree(state).resolveInner(pos), tree = around.resolve(pos, -1);
    for (let scan = pos, before; around == tree && (before = tree.childBefore(scan));) {
        let last = before.lastChild;
        if (!last || !last.type.isError || last.from < last.to)
            break;
        around = tree = before;
        scan = last.from;
    }
    if (tree.name == "TagName") {
        return tree.parent && /CloseTag$/.test(tree.parent.name) ? completeCloseTag(state, tree, tree.from, pos)
            : completeTag(state, schema, tree, tree.from, pos);
    }
    else if (tree.name == "StartTag") {
        return completeTag(state, schema, tree, pos, pos);
    }
    else if (tree.name == "StartCloseTag" || tree.name == "IncompleteCloseTag") {
        return completeCloseTag(state, tree, pos, pos);
    }
    else if (context.explicit && (tree.name == "OpenTag" || tree.name == "SelfClosingTag") || tree.name == "AttributeName") {
        return completeAttrName(state, schema, tree, tree.name == "AttributeName" ? tree.from : pos, pos);
    }
    else if (tree.name == "Is" || tree.name == "AttributeValue" || tree.name == "UnquotedAttributeValue") {
        return completeAttrValue(state, schema, tree, tree.name == "Is" ? pos : tree.from, pos);
    }
    else if (context.explicit && (around.name == "Element" || around.name == "Text" || around.name == "Document")) {
        return completeStartTag(state, schema, tree, pos);
    }
    else {
        return null;
    }
}
/// HTML tag completion. Opens and closes tags and attributes in a
/// context-aware way.
function htmlCompletionSource(context) {
    return htmlCompletionFor(Schema.default, context);
}
/// Create a completion source for HTML extended with additional tags
/// or attributes.
function htmlCompletionSourceWith(config) {
    let { extraTags, extraGlobalAttributes: extraAttrs } = config;
    let schema = extraAttrs || extraTags ? new Schema(extraTags, extraAttrs) : Schema.default;
    return (context) => htmlCompletionFor(schema, context);
}

// noinspection RegExpRedundantEscape,JSUnusedLocalSymbols
function indentBody(context, node) {
    let base = context.lineIndent(node.from);
    let line = context.lineAt(context.pos, -1), to = line.from + line.text.length;
    // Don't consider blank, deindented lines at the end of the
    // block part of the block
    if (!/\S/.test(line.text) &&
        context.node.to < to + 100 &&
        !/\S/.test(context.state.sliceDoc(to, context.node.to)) &&
        context.lineIndent(context.pos, -1) <= base)
        return null;
    // A normally deindenting keyword that appears at a higher
    // indentation than the block should probably be handled by the next
    // level
    if (/^\s*(else:|elif |except |finally:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base)
        return null;
    return base + context.unit;
}
let parserWithMetadata = parser.configure({
    props: [
        language.indentNodeProp.add({
            IfSet: language.continuedIndent({ except: /^\s*\}/ }),
            Array: language.continuedIndent({ except: /^\s*\]/ }),
            IfStatement: language.continuedIndent({ except: /^\s*\}/ }),
            // IfSet: context => indentBody(context, context.node) ?? context.continue(),
            // IfSet: cx =>  /^\s*\}$/.test(cx.textAfter) ? cx.baseIndent : cx.continue(),
            Script: context => {
                if (context.pos + /\s*/.exec(context.textAfter)[0].length >= context.node.to) {
                    let endBody = null;
                    for (let cur = context.node, to = cur.to;;) {
                        cur = cur.lastChild;
                        if (!cur || cur.to != to)
                            break;
                        if (cur.type.name == "Body")
                            endBody = cur;
                    }
                    if (endBody) {
                        let bodyIndent = indentBody(context, endBody);
                        if (bodyIndent != null)
                            return bodyIndent;
                    }
                }
                return context.continue();
            }
        }),
        language.foldNodeProp.add({
            "IfSet Object Array": language.foldInside
        }),
        highlight.styleTags({
            Identifier: highlight.tags.variableName,
            Boolean: highlight.tags.bool,
            String: highlight.tags.string,
            Comment: highlight.tags.comment,
            "( )": highlight.tags.paren
        }),
    ]
});
const SEELanguage = language.LRLanguage.define({
    parser: parserWithMetadata,
    languageData: {
        commentTokens: { line: "#" },
        indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:|set )$/
    },
});
const completions = [
    { "label": "CREATE", "type": "function" },
    { "label": "FORM", "type": "keyword" },
    { "label": "ENDFORM", "type": "keyword" },
    { "label": "VALIDATION", "type": "keyword" },
    { "label": "GIVEN", "type": "keyword" },
    { "label": "ENDGIVEN", "type": "keyword" },
    { "label": "IF", "type": "bool" },
    { "label": "AND", "type": "bool" },
    { "label": "OR", "type": "bool" },
    { "label": "SET", "type": "keyword" },
    { "label": "DISPLAY", "type": "keyword" },
    { "label": "END", "type": "book" },
    { "label": "ENDVALIDATION", "type": "keyword" },
    { "label": "ENDCREATE", "type": "keyword" },
    // DUMMY/TESTS
    { "label": "FOO", "type": "keyword" },
    { "label": "<html>", "type": "keyword" },
    { "label": "myuser", "type": "constant", "info": "Test completion" },
    { "label": "password", "type": "variable" }
];
const SEECompletion = SEELanguage.data.of({
    autocomplete: autocomplete.completeFromList(completions)
});
function SEE(config = {}) {
    return new language.LanguageSupport(SEELanguage, [SEECompletion, config.autoCloseTags !== false ? autoCloseTags : [],]);
}
const selfClosers = new Set("area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" "));
const autoCloseTags = view.EditorView.inputHandler.of((view, from, to, text) => {
    // if (view.composing || view.state.readOnly || from != to || (text != ">" && text != "/") ||
    //     !htmlLanguage.isActiveAt(view.state, from, -1)) return false
    let { state: state$1 } = view;
    let changes = state$1.changeByRange(range => {
        var _a, _b, _c;
        let { head } = range, around = language.syntaxTree(state$1).resolveInner(head, -1), name;
        if (around.name == "TagName" || around.name == "StartTag")
            around = around.parent;
        if (text == ">" && around.name == "OpenTag") {
            if (((_b = (_a = around.parent) === null || _a === void 0 ? void 0 : _a.lastChild) === null || _b === void 0 ? void 0 : _b.name) != "CloseTag" &&
                (name = elementName(state$1.doc, around.parent, head)) &&
                !selfClosers.has(name)) {
                let hasRightBracket = view.state.doc.sliceString(head, head + 1) === ">";
                let insert = `${hasRightBracket ? "" : ">"}</${name}>`;
                return { range: state.EditorSelection.cursor(head + 1), changes: { from: head + (hasRightBracket ? 1 : 0), insert } };
            }
        }
        else if (text == "/" && around.name == "OpenTag") {
            let empty = around.parent, base = empty === null || empty === void 0 ? void 0 : empty.parent;
            if (empty.from == head - 1 && ((_c = base.lastChild) === null || _c === void 0 ? void 0 : _c.name) != "CloseTag" &&
                (name = elementName(state$1.doc, base, head)) &&
                !selfClosers.has(name)) {
                let hasRightBracket = view.state.doc.sliceString(head, head + 1) === ">";
                let insert = `/${name}${hasRightBracket ? "" : ">"}`;
                let pos = head + insert.length + (hasRightBracket ? 1 : 0);
                return { range: state.EditorSelection.cursor(pos), changes: { from: head, insert } };
            }
        }
        return { range };
    });
    if (changes.changes.empty)
        return false;
    view.dispatch(changes, { userEvent: "input.type", scrollIntoView: true });
    return true;
});

exports.SEE = SEE;
exports.SEECompletion = SEECompletion;
exports.SEELanguage = SEELanguage;
exports.autoCloseTags = autoCloseTags;
exports.completions = completions;
exports.htmlCompletionSource = htmlCompletionSource;
exports.htmlCompletionSourceWith = htmlCompletionSourceWith;
exports.parserWithMetadata = parserWithMetadata;
