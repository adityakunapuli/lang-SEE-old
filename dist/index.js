import { LRParser } from '@lezer/lr';
import { indentNodeProp, delimitedIndent, foldNodeProp, foldInside, LRLanguage, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@lezer/highlight';
import { completeFromList } from '@codemirror/autocomplete';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const parser = LRParser.deserialize({
  version: 14,
  states: "!WQYQPOOOhQPO'#CdOOQO'#Ci'#CiOOQO'#Ce'#CeQYQPOOOOQO,59O,59OOyQPO,59OOOQO-E6c-E6cOOQO1G.j1G.j",
  stateData: "![~O[OSPOS~ORQOSQOTQOVPO~ORQOSQOTQOUTOVPO~ORQOSQOTQOUWOVPO~O",
  goto: "u^PPPPPPPP_ePPPoXQOPSUQSOQUPTVSUXROPSU",
  nodeNames: "âš  LineComment Program Identifier String Boolean ) ( Application",
  maxTerm: 13,
  nodeProps: [
    ["openedBy", 6,"("],
    ["closedBy", 7,")"]
  ],
  skippedNodes: [0,1],
  repeatNodeCount: 1,
  tokenData: "%c~R^XY}YZ}]^}pq}rs!`st#|xy$[yz$a}!O$f!Q![$f!]!^$z!c!}$f#R#S$f#T#o$f~!SS[~XY}YZ}]^}pq}~!cVOr!`rs!xs#O!`#O#P!}#P;'S!`;'S;=`#v<%lO!`~!}OS~~#QRO;'S!`;'S;=`#Z;=`O!`~#^WOr!`rs!xs#O!`#O#P!}#P;'S!`;'S;=`#v;=`<%l!`<%lO!`~#yP;=`<%l!`~$PQ#Y#Z$V#h#i$V~$[OT~~$aOV~~$fOU~~$kTR~}!O$f!Q![$f!c!}$f#R#S$f#T#o$f~%PSP~OY$zZ;'S$z;'S;=`%]<%lO$z~%`P;=`<%l$z",
  tokenizers: [0],
  topRules: {"Program":[0,2]},
  tokenPrec: 0
});

// import {parser} from "./syntax.grammar"
let parserWithMetadata = parser.configure({
    props: [
        indentNodeProp.add({
            Application: delimitedIndent({ closing: ")", align: false })
        }),
        foldNodeProp.add({
            Application: foldInside
        }),
        styleTags({
            Identifier: tags.variableName,
            Boolean: tags.bool,
            String: tags.string,
            LineComment: tags.lineComment,
            "( )": tags.paren
        }),
        indentNodeProp.add({
            Application: context => context.column(context.node.from) + context.unit
        })
    ]
});
const SEELanguage = LRLanguage.define({
    parser: parserWithMetadata,
    languageData: {
        commentTokens: { line: ";" }
    }
});
// let syntax = [
//     {"label": "CREATE", "type": "keyword"},
//     {"label": "FORM", "type": "keyword"},
//     {"label": "ENDFORM", "type": "keyword"},
//     {"label": "VALIDATION", "type": "keyword"},
//     {"label": "GIVEN", "type": "keyword"},
//     {"label": "ENDGIVEN", "type": "keyword"},
//     {"label": "IF", "type": "keyword"},
//     {"label": "AND", "type": "keyword"},
//     {"label": "OR", "type": "keyword"},
//     {"label": "SET", "type": "keyword"},
//     {"label": "DISPLAY MSG", "type": "keyword"},
//     {"label": "END", "type": "keyword"},
//     {"label": "ENDVALIDATION", "type": "keyword"},
//     {"label": "ENDCREATE", "type": "keyword"}
// ]
const SEECompletion = SEELanguage.data.of({
    autocomplete: completeFromList([
        { label: "defun", type: "keyword" },
        { label: "defvar", type: "keyword" },
        { label: "let", type: "keyword" },
        { label: "cons", type: "function" },
        { label: "car", type: "function" },
        { label: "cdr", type: "function" }
    ])
});
function SEE() {
    return new LanguageSupport(SEELanguage, [SEECompletion]);
}

export { SEE, SEECompletion, SEELanguage, parserWithMetadata };
